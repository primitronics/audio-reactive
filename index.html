<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Audio‑Reactive Nature Visuals — Mix & Match</title>
  <style>
    :root { --bg:#0b0c10; --fg:#e6eef7; }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui,"Hiragino Kaku Gothic ProN","Yu Gothic",Meiryo,sans-serif}
    #hud{position:fixed;left:12px;right:12px;bottom:12px;display:flex;flex-wrap:wrap;gap:10px;align-items:center;background:rgba(0,0,0,.45);backdrop-filter:blur(8px);padding:10px 12px;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);z-index:10;transition:transform .25s ease, opacity .25s ease}
    #hud.hidden{transform:translateY(20px);opacity:0;pointer-events:none}
    #hud .group{display:flex;gap:8px;align-items:center}
    #hud label{font-size:12px;opacity:.9}
    #hud input[type="range"]{width:120px}
    #hud button,#hud select{appearance:none;border:1px solid rgba(255,255,255,.15);background:#111418;color:var(--fg);padding:8px 10px;border-radius:10px;cursor:pointer}
    #hud button:hover{border-color:rgba(255,255,255,.35)}
    #fps{font-variant-numeric:tabular-nums;opacity:.6;font-size:12px}
    #notice{position:fixed;top:12px;left:12px;right:12px;background:rgba(255,255,255,.07);border:1px solid rgba(255,255,255,.15);padding:8px 12px;border-radius:12px;backdrop-filter:blur(6px);font-size:13px;z-index:9}
    #toggleHUD{position:fixed;top:12px;right:12px;z-index:11;appearance:none;border:1px solid rgba(255,255,255,.15);background:#111418;color:var(--fg);padding:8px 10px;border-radius:10px;cursor:pointer}
    #toggleHUD:hover{border-color:rgba(255,255,255,.35)}
    canvas{display:block;position:fixed;inset:0}
  </style>
</head>
<body>
  <canvas id="cv"></canvas>
  <div id="notice">🎥 フリー素材動画は<b>media/</b>に配置してください（例: <code>media/forest.mp4</code>）。<br>「🎤 マイク開始」で音反応（HTTPS/localhostが必要）。下のドロップダウンで<b>映像</b>と<b>モーション</b>を別々に選べます。<br>⚙️ <b>パネル表示/非表示</b>は右上ボタンか <kbd>H</kbd> で切替。</div>
  <button id="toggleHUD">⚙️ パネル非表示</button>
  <div id="hud">
    <div class="group"><button id="micBtn">🎤 マイク開始</button></div>
    <div class="group"><label>感度<input id="sens" type="range" min="0.05" max="0.8" value="0.25" step="0.01"></label></div>
    <div class="group"><label>スムージング<input id="smooth" type="range" min="0" max="0.95" value="0.7" step="0.01"></label></div>
    <div class="group"><label>FFT<input id="fft" type="range" min="512" max="4096" value="2048" step="512"></label></div>

    <div class="group"><label>映像<select id="videoSel"></select></label></div>
    <div class="group"><label>モーション<select id="motionSel"></select></label></div>

    <div class="group"><label><input id="auto" type="checkbox" checked> ビートで自動切替（映像）</label></div>
    <div class="group"><label><input id="kickOnly" type="checkbox" checked> キック優先</label></div>

    <!-- ▼ 強度スライダー -->
    <div class="group"><label>歪み強度<input id="distAmt" type="range" min="0" max="1" value="0.6" step="0.01"></label></div>
    <div class="group"><label>色相変化<input id="hueAmt" type="range" min="0" max="1" value="0.8" step="0.01"></label></div>
    <div class="group"><label>彩度反応<input id="satAmt" type="range" min="0" max="1" value="0.8" step="0.01"></label></div>
    <div class="group"><label>輝度反応<input id="valAmt" type="range" min="0" max="1" value="0.6" step="0.01"></label></div>
    <div class="group"><label>グロウ量<input id="bloomAmt" type="range" min="0" max="1" value="0.6" step="0.01"></label></div>

    <div class="group"><button id="addUrl">URL追加</button><input id="filePick" type="file" accept="video/*" style="display:none"><button id="addFile">ローカル追加</button></div>
    <div class="group"><span id="fps">FPS: --</span></div>
  </div>

<script type="module">
// Three.js from CDN
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

// ---------- Renderer ----------
const dpr = Math.min(2, window.devicePixelRatio||1);
const canvas = document.getElementById('cv');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:false});
const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
renderer.setPixelRatio(dpr);
function resize(){ renderer.setSize(innerWidth, innerHeight, false);} resize(); addEventListener('resize', resize);

// ---------- Shader (distortion + color) ----------
const vertexShader = `
  varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.0); }
`;
const fragmentShader = `
  precision highp float; varying vec2 vUv; uniform sampler2D tex0; uniform sampler2D tex1; uniform float uMix; uniform float uTime; uniform vec2 uRes; 
  uniform float uLow; uniform float uMid; uniform float uHigh; uniform float uVol; 
  uniform int uMotion; // 0..9 presets
  uniform float uDistAmt; uniform float uHueAmt; uniform float uSatAmt; uniform float uValAmt; uniform float uBloomAmt;

  float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7)))*43758.5453123); }
  float noise(vec2 p){ vec2 i=floor(p); vec2 f=fract(p); float a=hash(i); float b=hash(i+vec2(1.,0.)); float c=hash(i+vec2(0.,1.)); float d=hash(i+vec2(1.,1.)); vec2 u=f*f*(3.-2.*f); return mix(a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y; }
  vec3 rgb2hsv(vec3 c){ vec4 K=vec4(0.,-1./3.,2./3.,-1.); vec4 p=mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b,c.g)); vec4 q=mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x,c.r)); float d=q.x-min(q.w, q.y); float e=1e-10; return vec3(abs(q.z+(q.w-q.y)/(6.*d+e)), d/(q.x+e), q.x); }
  vec3 hsv2rgb(vec3 c){ vec4 K=vec4(1.,2./3.,1./3.,3.); vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www); return c.z*mix(K.xxx, clamp(p-K.xxx,0.,1.), c.y); }

  vec4 sampleTex(sampler2D t, vec2 uv){ return texture2D(t, uv); }

  void main(){
    vec2 uv = vUv; vec2 res=uRes; float aspect = res.x/res.y; 

    if (uMotion==0){ vec2 p=uv*vec2(aspect,1.0); float r=length(p-vec2(0.5*aspect,0.5)); float dist = sin(10.0*r - uTime*4.0)*(0.004+0.02*uLow)*uDistAmt; uv += dist*normalize(p-vec2(0.5*aspect,0.5)); }
    else if (uMotion==1){ uv += (noise(uv*8.0+uTime*0.6)-0.5)*0.04*(0.2+uMid*0.01)*uDistAmt; }
    else if (uMotion==2){ uv.y += sin(uv.x*12.0+uTime*2.0)*0.02*(0.2+uLow*0.01)*uDistAmt; }
    else if (uMotion==3){ uv += (noise(uv*5.0+uTime)-0.5)*0.02*(0.2+uHigh*0.01)*uDistAmt; }
    else if (uMotion==4){ uv += (noise(uv*15.0+uTime*0.8)-0.5)*0.025*(0.2+uMid*0.01)*uDistAmt; }
    else if (uMotion==5){ uv += vec2(0.0, sin(uv.x*20.0+uTime*3.0))*0.015*(0.2+uHigh*0.015)*uDistAmt; }
    else if (uMotion==6){ uv += (noise(uv*30.0+uTime*1.5)-0.5)*0.015*(0.2+uLow*0.02)*uDistAmt; }
    else if (uMotion==7){ uv += vec2(sin(uv.y*14.0+uTime*2.0), cos(uv.x*14.0+uTime*2.0))*0.012*(0.2+uLow*0.02)*uDistAmt; }
    else if (uMotion==8){ uv += (noise(uv*10.0+uTime*1.2)-0.5)*0.03*(0.2+uMid*0.02)*uDistAmt; }
    else { uv += (noise(uv*6.0+uTime*0.7)-0.5)*0.02*(0.2+uMid*0.01)*uDistAmt; }

    vec4 a = sampleTex(tex0, uv);
    vec4 b = sampleTex(tex1, uv);
    vec4 col = mix(a, b, uMix);

    vec3 hsv = rgb2hsv(col.rgb);
    float hueShift = (0.25*uHigh)*uHueAmt + 0.1*sin(uTime*0.2);
    hsv.x = fract(hsv.x + hueShift);
    hsv.y = clamp(hsv.y * (1.0 + 0.8*uMid*uSatAmt), 0.0, 1.0);
    hsv.z = clamp(hsv.z * (0.8 + 0.6*uVol*uValAmt), 0.0, 2.0);
    vec3 rgb = hsv2rgb(hsv);

    float vg = smoothstep(0.9, 0.2, length(vUv-0.5));
    rgb += vec3(vg)*0.15*uHigh*uBloomAmt;

    float g = (noise(vUv*vec2(800.0,600.0)+uTime*60.0)-0.5)*0.05; rgb += g;
    gl_FragColor = vec4(rgb, 1.0);
  }
`;

const uniforms = {
  tex0: {value: new THREE.Texture()}, tex1: {value: new THREE.Texture()}, uMix:{value:0}, 
  uTime:{value:0}, uRes:{value:new THREE.Vector2(innerWidth, innerHeight)},
  uLow:{value:0}, uMid:{value:0}, uHigh:{value:0}, uVol:{value:0},
  uMotion:{value:0},
  uDistAmt:{value:0.6}, uHueAmt:{value:0.8}, uSatAmt:{value:0.8}, uValAmt:{value:0.6}, uBloomAmt:{value:0.6}
};
const material = new THREE.ShaderMaterial({vertexShader, fragmentShader, uniforms});
const quad = new THREE.Mesh(new THREE.PlaneGeometry(2,2), material); scene.add(quad);

// ---------- Video pool (base footage) ----------
const defaultVideos = [
  {title:'Forest / Wind', file:'media/forest.mp4'},
  {title:'Ocean / Waves', file:'media/ocean.mp4'},
  {title:'Night Sky / Stars', file:'media/stars.mp4'},
  {title:'Clouds', file:'media/clouds.mp4'},
  {title:'Mountains', file:'media/mountains.mp4'},
  {title:'Snow Field', file:'media/snow.mp4'},
  {title:'Desert', file:'media/desert.mp4'},
  {title:'Rainy City', file:'media/rain_city.mp4'},
  {title:'Lake Surface', file:'media/lake.mp4'},
  {title:'Steam / Geyser', file:'media/steam.mp4'}
];
let videos = [...defaultVideos];
const videoEls = [];
function makeVideo(src){ const v=document.createElement('video'); v.src=src; v.crossOrigin='anonymous'; v.loop=true; v.muted=true; v.playsInline=true; v.preload='auto'; v.addEventListener('error',()=>console.warn('Video load error:',src)); return v; }
function ensureVideoEls(){ videoEls.length=0; for(const v of videos) videoEls.push(makeVideo(v.file)); }
ensureVideoEls();

// ---------- Motion presets ----------
const motions = [
  {name:'Water Ripple', id:0}, {name:'Heat Haze', id:1}, {name:'Wind Sway', id:2}, {name:'Star Pulse', id:3}, {name:'Glacier Crack', id:4},
  {name:'Desert Shimmer', id:5}, {name:'Rain Droplet', id:6}, {name:'Lake Ripple', id:7}, {name:'Steam Swirl', id:8}, {name:'Cloud Drift', id:9}
];

// ---------- UI ----------
const micBtn = document.getElementById('micBtn');
const sensEl = document.getElementById('sens');
const smoothEl = document.getElementById('smooth');
const fftEl = document.getElementById('fft');
const videoSel = document.getElementById('videoSel');
const motionSel = document.getElementById('motionSel');
const autoChk = document.getElementById('auto');
const kickOnlyChk = document.getElementById('kickOnly');
const addUrlBtn = document.getElementById('addUrl');
const addFileBtn = document.getElementById('addFile');
const filePick = document.getElementById('filePick');
const fpsEl = document.getElementById('fps');
const toggleBtn = document.getElementById('toggleHUD');
const hud = document.getElementById('hud');

// intensity sliders
const distAmtEl = document.getElementById('distAmt');
const hueAmtEl  = document.getElementById('hueAmt');
const satAmtEl  = document.getElementById('satAmt');
const valAmtEl  = document.getElementById('valAmt');
const bloomAmtEl= document.getElementById('bloomAmt');

function populateSelects(){
  videoSel.innerHTML=''; videos.forEach((v,i)=>{ const o=document.createElement('option'); o.value=i; o.textContent=`${i+1}. ${v.title}`; videoSel.appendChild(o); });
  motionSel.innerHTML=''; motions.forEach((m,i)=>{ const o=document.createElement('option'); o.value=m.id; o.textContent=`${i+1}. ${m.name}`; motionSel.appendChild(o); });
  videoSel.value = '0'; motionSel.value='0';
}
populateSelects();

// ---------- Playback / Crossfade ----------
let curVideo = 0; let nextVideo = 1; let fading=false; let fadeT=0; const FADE_DUR=1.2;

function setTextures(i,j){
  const vi=videoEls[i]; const vj=videoEls[j];
  uniforms.tex0.value = new THREE.VideoTexture(vi);
  uniforms.tex1.value = new THREE.VideoTexture(vj);
  uniforms.tex0.value.minFilter = uniforms.tex0.value.magFilter = THREE.LinearFilter;
  uniforms.tex1.value.minFilter = uniforms.tex1.value.magFilter = THREE.LinearFilter;
}
function playIndex(i){ const v=videoEls[i]; v.currentTime=0; v.play().catch(()=>{}); }
function startVideo(i){ curVideo=i; nextVideo=(i+1)%videos.length; playIndex(curVideo); playIndex(nextVideo); setTextures(curVideo,nextVideo); }
startVideo(0);

function crossfadeToVideo(i){ if (i===curVideo||fading) return; nextVideo=i; playIndex(nextVideo); setTextures(curVideo,nextVideo); fading=true; fadeT=0; }
function setMotion(id){ uniforms.uMotion.value = id; }

videoSel.addEventListener('change', ()=>{ const i=parseInt(videoSel.value,10)||0; crossfadeToVideo(i); });
motionSel.addEventListener('change', ()=>{ const id=parseInt(motionSel.value,10)||0; setMotion(id); });

addUrlBtn.addEventListener('click', ()=>{ const url=prompt('動画URL（mp4/webm, CORS許可が必要）'); if(!url) return; const title=prompt('シーン名','Custom')||'Custom'; videos.push({title,file:url}); videoEls.push(makeVideo(url)); populateSelects(); });
addFileBtn.addEventListener('click', ()=> filePick.click());
filePick.addEventListener('change', ()=>{ const f=filePick.files[0]; if(!f) return; const url=URL.createObjectURL(f); videos.push({title:f.name,file:url}); videoEls.push(makeVideo(url)); populateSelects(); });

// ---------- Audio ----------
let actx, analyser, freq, time; let started=false; let sampleRate=48000; let energyEMA=0, emaAlpha=0.15, lastBeat=0; const MIN_BEAT_GAP=0.18; let lastTs=performance.now();
function hzToBin(hz){ return Math.round(hz * analyser.fftSize / sampleRate); }
function bandEnergy(f, a,b){ const s=Math.max(0,hzToBin(a)); const e=Math.min(f.length-1,hzToBin(b)); let sum=0; for(let i=s;i<=e;i++) sum+=f[i]; return sum/Math.max(1,(e-s+1)); }
function detectBeat(){ const low=bandEnergy(freq,20,180), mid=bandEnergy(freq,180,2000), high=bandEnergy(freq,2000,9000); const overall=(low*1.6+mid+high*0.6)/3.2; const sens=parseFloat(sensEl.value); energyEMA = energyEMA===0? overall : energyEMA*(1-emaAlpha)+overall*emaAlpha; const now=performance.now()/1000; const isBeat = overall>energyEMA*(1+sens) && (now-lastBeat)>MIN_BEAT_GAP; const kickBeat = low>energyEMA*(1+sens*0.8); if(isBeat) lastBeat=now; return {isBeat,kickBeat,low,mid,high,overall}; }
async function start(){ if(started){ stop(); return; } try{ actx=new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'}); sampleRate=actx.sampleRate; analyser=actx.createAnalyser(); analyser.fftSize=parseInt(fftEl.value,10); analyser.smoothingTimeConstant=parseFloat(smoothEl.value); const stream=await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:true,noiseSuppression:true,autoGainControl:true}}); const src=actx.createMediaStreamSource(stream); src.connect(analyser); freq=new Uint8Array(analyser.frequencyBinCount); time=new Uint8Array(analyser.fftSize); started=true; micBtn.textContent='⏹ 停止'; }catch(err){ alert('マイク権限エラー: '+err.name+' '+err.message); } }
function stop(){ started=false; micBtn.textContent='🎤 マイク開始'; if(actx) actx.close(); }
micBtn.addEventListener('click', start);
fftEl.addEventListener('input', ()=>{ if(analyser){ analyser.fftSize=parseInt(fftEl.value,10); freq=new Uint8Array(analyser.frequencyBinCount); time=new Uint8Array(analyser.fftSize);} });
smoothEl.addEventListener('input', ()=>{ if(analyser) analyser.smoothingTimeConstant=parseFloat(smoothEl.value); });

let autoSwitch=true; autoChk.addEventListener('change', ()=> autoSwitch=autoChk.checked);

// ---------- Loop ----------
function loop(){ requestAnimationFrame(loop); const now=performance.now(); const dt=Math.max(0,(now-lastTs)/1000); lastTs=now; uniforms.uTime.value+=dt; uniforms.uRes.value.set(innerWidth,innerHeight);
  // update slider uniforms
  uniforms.uDistAmt.value = parseFloat(distAmtEl.value);
  uniforms.uHueAmt.value  = parseFloat(hueAmtEl.value);
  uniforms.uSatAmt.value  = parseFloat(satAmtEl.value);
  uniforms.uValAmt.value  = parseFloat(valAmtEl.value);
  uniforms.uBloomAmt.value= parseFloat(bloomAmtEl.value);

  if(analyser){ analyser.getByteFrequencyData(freq); analyser.getByteTimeDomainData(time); const info=detectBeat(); uniforms.uLow.value=info.low/255; uniforms.uMid.value=info.mid/255; uniforms.uHigh.value=info.high/255; uniforms.uVol.value=info.overall/255; if(autoSwitch && info.isBeat && (!kickOnlyChk.checked || info.kickBeat)){ const nx=(curVideo+1)%videos.length; crossfadeToVideo(nx); videoSel.value=String(nx); } }
  if(fading){ fadeT+=dt; uniforms.uMix.value=Math.min(1, fadeT/FADE_DUR); if(uniforms.uMix.value>=1){ curVideo=nextVideo; fading=false; uniforms.uMix.value=0; setTextures(curVideo,(curVideo+1)%videos.length); } }
  renderer.render(scene,camera);
}
loop();

// start all videos on first interaction (iOS対策)
addEventListener('pointerdown', ()=>{ for(const v of videoEls){ v.play().catch(()=>{}); } }, {once:true});

// keyboard: space -> next video, H -> toggle panel
addEventListener('keydown',(e)=>{ if(e.key===' '){ e.preventDefault(); autoChk.checked=false; autoSwitch=false; const nx=(curVideo+1)%videos.length; crossfadeToVideo(nx); videoSel.value=String(nx);} if(e.key.toLowerCase()==='h'){ toggleHUD(); }});

// FPS meter
let lt=performance.now(), frames=0; setInterval(()=>{ const now=performance.now(); frames++; if(now-lt>1000){ fpsEl.textContent='FPS: '+frames; frames=0; lt=now; } }, 200);

// initial motion
setMotion(0);

// HUD toggle
function toggleHUD(){ hud.classList.toggle('hidden'); const isHidden=hud.classList.contains('hidden'); toggleBtn.textContent = isHidden? '⚙️ パネル表示' : '⚙️ パネル非表示'; }

toggleBtn.addEventListener('click', toggleHUD);
</script>
</body>
</html>
