<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Audio‚ÄëReactive Visual Switcher</title>
  <style>
    :root { --bg:#0b0c10; --fg:#e5e7eb; --accent:#60a5fa; }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui,"Hiragino Kaku Gothic ProN","Yu Gothic",Meiryo,sans-serif}
    #hud{position:fixed;inset:auto 12px 12px 12px;display:flex;flex-wrap:wrap;gap:10px;align-items:center;background:rgba(0,0,0,.45);backdrop-filter:blur(6px);padding:10px 12px;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.3)}
    #hud .group{display:flex;gap:8px;align-items:center}
    #hud label{font-size:12px;opacity:.9}
    #hud input[type="range"]{width:120px}
    #hud button,#hud select{appearance:none;border:1px solid rgba(255,255,255,.15);background:#111418;color:var(--fg);padding:8px 10px;border-radius:10px;cursor:pointer}
    #hud button:hover{border-color:rgba(255,255,255,.35)}
    #fps{font-variant-numeric:tabular-nums;opacity:.6;font-size:12px}
    canvas{display:block;position:fixed;inset:0}
  </style>
</head>
<body>
  <canvas id="cv"></canvas>
  <div id="hud">
    <div class="group"><button id="micBtn">üé§ „Éû„Ç§„ÇØÈñãÂßã</button></div>
    <div class="group"><label>ÊÑüÂ∫¶<input id="sens" type="range" min="0.05" max="0.8" value="0.25" step="0.01"></label></div>
    <div class="group"><label>„Çπ„É†„Éº„Ç∏„É≥„Ç∞<input id="smooth" type="range" min="0" max="0.95" value="0.7" step="0.01"></label></div>
    <div class="group"><label>FFT<input id="fft" type="range" min="512" max="4096" value="2048" step="512"></label></div>
    <div class="group"><label>„Ç∑„Éº„É≥<select id="sceneSel"></select></label></div>
    <div class="group"><label><input id="auto" type="checkbox" checked> „Éì„Éº„Éà„ÅßËá™ÂãïÂàáÊõø</label></div>
    <div class="group"><label><input id="kickOnly" type="checkbox" checked> „Ç≠„ÉÉ„ÇØÂÑ™ÂÖà</label></div>
    <div class="group"><span id="fps">FPS: --</span></div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('cv');
  const ctx = canvas.getContext('2d');
  let W = 0, H = 0, dpr = Math.min(2, window.devicePixelRatio || 1);
  function resize(){ W = innerWidth; H = innerHeight; canvas.width = W*dpr; canvas.height = H*dpr; canvas.style.width = W+'px'; canvas.style.height = H+'px'; ctx.setTransform(dpr,0,0,dpr,0,0);} resize();
  addEventListener('resize', resize);

  // UI refs
  const micBtn = document.getElementById('micBtn');
  const sensEl = document.getElementById('sens');
  const smoothEl = document.getElementById('smooth');
  const fftEl = document.getElementById('fft');
  const sceneSel = document.getElementById('sceneSel');
  const autoChk = document.getElementById('auto');
  const kickOnlyChk = document.getElementById('kickOnly');
  const fpsEl = document.getElementById('fps');

  // Audio
  let actx, analyser, src, freq, time, rafId;
  let started = false;
  let sampleRate = 48000;

  const scenes = [];
  let sceneIndex = 0;
  let t = 0;

  // Beat detection using EMA baseline
  let energyEMA = 0, emaAlpha = 0.15, lastBeat = 0;
  const MIN_BEAT_GAP = 0.18; // seconds

  function hzToBin(hz){ return Math.round(hz * analyser.fftSize / sampleRate); }
  function bandEnergy(f, startHz, endHz){
    const s = Math.max(0, hzToBin(startHz));
    const e = Math.min(f.length-1, hzToBin(endHz));
    let sum = 0; for (let i=s;i<=e;i++) sum += f[i];
    return sum / Math.max(1, (e - s + 1));
  }

  function detectBeat(dt){
    const low = bandEnergy(freq, 20, 180); // kick
    const mid = bandEnergy(freq, 180, 2000);
    const high = bandEnergy(freq, 2000, 9000);
    const overall = (low*1.6 + mid + high*0.6) / 3.2;
    const sensitivity = parseFloat(sensEl.value);
    energyEMA = energyEMA === 0 ? overall : energyEMA*(1-emaAlpha) + overall*emaAlpha;
    const now = performance.now()/1000;
    const isBeat = overall > energyEMA * (1 + sensitivity) && (now - lastBeat) > MIN_BEAT_GAP;
    const kickBeat = low > energyEMA * (1 + sensitivity*0.8);
    if (isBeat) lastBeat = now;
    return { isBeat, kickBeat, low, mid, high, overall };
  }

  function switchScene(dir=1){
    sceneIndex = (sceneIndex + dir + scenes.length) % scenes.length;
    sceneSel.value = sceneIndex;
    // small flash
    flashTimer = 0.12;
  }

  // Simple flash overlay on switch
  let flashTimer = 0;

  // --- Scene 1: Waveform ribbons ---
  scenes.push(function sceneWave(){
    ctx.fillStyle = '#0b0c10';
    ctx.fillRect(0,0,W,H);
    if (!time) return;
    const n = 4; const step = Math.max(256, time.length);
    for (let k=0;k<n;k++){
      const yBase = H*(0.2 + 0.2*k);
      ctx.beginPath();
      for (let i=0;i<time.length;i+=2){
        const x = i/time.length * W;
        const v = (time[i]-128)/128; // -1..1
        const y = yBase + v * (80 + 40*k);
        i===0? ctx.moveTo(x,y) : ctx.lineTo(x,y);
      }
      ctx.lineWidth = 2+k*1.2;
      ctx.strokeStyle = `rgba(96,165,250,${0.9 - k*0.18})`;
      ctx.stroke();
    }
  });

  // --- Scene 2: Spectrum bars with peak hold ---
  const peaks = new Float32Array(256);
  scenes.push(function sceneBars(){
    ctx.fillStyle = '#0b0c10';
    ctx.fillRect(0,0,W,H);
    if (!freq) return;
    const bins = 128; // sample subset
    const bw = W / bins;
    for (let i=0;i<bins;i++){
      const idx = Math.floor(i * (freq.length/bins));
      const v = freq[idx] / 255; // 0..1
      const h = v * (H*0.9);
      // bars
      ctx.fillStyle = '#60a5fa';
      ctx.fillRect(i*bw, H-h, bw*0.9, h);
      // peaks
      peaks[i] = Math.max(peaks[i]*0.985, h);
      ctx.fillStyle = 'rgba(255,255,255,.6)';
      ctx.fillRect(i*bw, H-peaks[i]-3, bw*0.9, 3);
    }
  });

  // --- Scene 3: Particle burst ---
  const particles = [];
  function spawnBurst(n, power){
    for (let i=0;i<n;i++){
      const a = Math.random()*Math.PI*2;
      const s = (Math.random()*power + power*0.5);
      particles.push({x:W/2,y:H/2,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:1});
    }
  }
  scenes.push(function sceneParticles(){
    ctx.fillStyle = 'rgba(11,12,16,0.25)';
    ctx.fillRect(0,0,W,H);
    for (let p of particles){
      p.x += p.vx; p.y += p.vy; p.vx *= 0.985; p.vy *= 0.985; p.life *= 0.985;
      ctx.beginPath(); ctx.arc(p.x,p.y, 2 + (1-p.life)*8, 0, Math.PI*2);
      ctx.fillStyle = `rgba(96,165,250,${p.life})`;
      ctx.fill();
    }
    // remove dead
    for (let i=particles.length-1;i>=0;i--) if (particles[i].life<0.04) particles.splice(i,1);
  });

  // --- Scene 4: Radial blobs ---
  scenes.push(function sceneRadial(){
    ctx.fillStyle = '#0b0c10';
    ctx.fillRect(0,0,W,H);
    if (!freq) return;
    const cx=W/2, cy=H/2; const R = Math.min(W,H)*0.38;
    ctx.save(); ctx.translate(cx,cy);
    const bins = 180;
    ctx.beginPath();
    for (let i=0;i<=bins;i++){
      const idx = Math.floor(i * (freq.length/bins));
      const v = (freq[idx]/255);
      const angle = (i/bins)*Math.PI*2 + t*0.2;
      const r = R*(0.6 + v*0.8);
      const x = Math.cos(angle)*r, y = Math.sin(angle)*r;
      i===0? ctx.moveTo(x,y):ctx.lineTo(x,y);
    }
    ctx.closePath();
    const grd = ctx.createRadialGradient(0,0,10,0,0,R*1.2);
    grd.addColorStop(0,'rgba(96,165,250,0.9)');
    grd.addColorStop(1,'rgba(96,165,250,0.05)');
    ctx.fillStyle = grd; ctx.fill();
    ctx.restore();
  });

  // populate scene select
  const sceneNames = ['Waveform','Bars','Particles','Radial'];
  sceneNames.forEach((n,i)=>{
    const opt=document.createElement('option'); opt.value=i; opt.textContent=`${i+1}. ${n}`; sceneSel.appendChild(opt);
  });
  sceneSel.value = sceneIndex;
  sceneSel.addEventListener('change', ()=>{ sceneIndex = parseInt(sceneSel.value,10)||0; flashTimer=0.08; });

  async function start(){
    if (started) return stop();
    try{
      actx = new (window.AudioContext || window.webkitAudioContext)({latencyHint:'interactive'});
      sampleRate = actx.sampleRate;
      analyser = actx.createAnalyser();
      analyser.fftSize = parseInt(fftEl.value,10);
      analyser.smoothingTimeConstant = parseFloat(smoothEl.value);

      const stream = await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:true,noiseSuppression:true,autoGainControl:true}});
      src = actx.createMediaStreamSource(stream);
      src.connect(analyser);

      freq = new Uint8Array(analyser.frequencyBinCount);
      time = new Uint8Array(analyser.fftSize);

      started = true;
      micBtn.textContent = '‚èπ ÂÅúÊ≠¢';
      loop();
    } catch(err){
      alert('„Éû„Ç§„ÇØ„ÅÆ‰ΩøÁî®„ÅåË®±ÂèØ„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü: '+err.message);
    }
  }

  function stop(){
    if (!started) return;
    if (src && src.mediaStream){ src.mediaStream.getTracks().forEach(t=>t.stop()); }
    if (actx) actx.close();
    cancelAnimationFrame(rafId);
    started = false; micBtn.textContent = 'üé§ „Éû„Ç§„ÇØÈñãÂßã';
  }

  micBtn.addEventListener('click', start);
 fftEl.addEventListener('input', ()=>{ if (analyser){ analyser.fftSize=parseInt(fftEl.value,10); freq=new Uint8Array(analyser.frequencyBinCount); time=new Uint8Array(analyser.fftSize); }});
  smoothEl.addEventListener('input', ()=>{ if (analyser){ analyser.smoothingTimeConstant=parseFloat(smoothEl.value); }});

  let last = performance.now();
  function loop(){
    rafId = requestAnimationFrame(loop);
    const now = performance.now();
    const dt = Math.max(0,(now-last)/1000); last = now; t += dt;

    if (analyser){ analyser.getByteFrequencyData(freq); analyser.getByteTimeDomainData(time); }

    // render scene
    scenes[sceneIndex]();

    // beat logic
    if (analyser){
      const info = detectBeat(dt);
      // particles react each frame to bass/mid/high
      const bass = info.low, treble = info.high;
      if (bass>90) spawnBurst(6, Math.min(8, bass/10));

      if (autoChk.checked && info.isBeat){
        if (kickOnlyChk.checked){ if (info.kickBeat) switchScene(+1); }
        else switchScene(+1);
      }
    }

    // flash overlay on switch
    if (flashTimer>0){
      ctx.fillStyle = `rgba(255,255,255,${flashTimer*1.2})`;
      ctx.fillRect(0,0,W,H); flashTimer -= dt;
    }

    // FPS
    fpsEl.textContent = 'FPS: ' + Math.round(1/dt);
  }

  // Keyboard shortcuts
  addEventListener('keydown', (e)=>{
    if (e.key===' ') { e.preventDefault(); if (autoChk.checked) autoChk.checked=false; switchScene(+1); }
    if (e.key==='ArrowLeft') switchScene(-1);
    if (e.key==='ArrowRight') switchScene(+1);
  });
})();
</script>
</body>
</html>
